(define-module (bad-cat nfldb ui controls preview-cairo)
  ;; *******************************************************************************************************************
  ;; Define the function for drawing the game's plays
  ;; *******************************************************************************************************************

  #:use-module (oop goops)
  #:use-module (cairo)

  #:use-module (g-golf)

  #:use-module (bad-cat utils)

  #:use-module (bad-cat nfldb play)
  #:use-module (bad-cat nfldb game)
  #:use-module (bad-cat nfldb team)

  #:use-module (bad-cat nfldb cache schedule)
  #:use-module (bad-cat nfldb cache result)
  #:use-module (bad-cat nfldb cache league)
  #:use-module (bad-cat nfldb cache standings)

  #:export (make-week-preview-control)
  ; #:export (play-type->renderer)
  ; #:export (play-renderer-height)
  ; #:export (play-renderer-draw)
)

(define (make-week-preview-control year-no week-no w h)
  (let ( (panel (make-instance <gtk-drawing-area>
                               #:content-height w
                               #:content-width  h)) )
    (let ( (draw-func (make-week-preview-draw-func year-no week-no)) )
      (gtk-drawing-area-set-draw-func panel draw-func #f #f))
    panel))

;; Primary Values
(define box-height      32)
(define info-width      48)
(define team-space      4)
(define div-space       16)
(define graph-width     500)

;; Derived Values
(define box-width (+ info-width (* 2 box-height)))

(define (make-week-preview-draw-func year-no week-no)
  (lambda (drawing-area cr-ptr width height user-data)
    (let ( (cr (cairo-pointer->context cr-ptr)) )
      (let ( (box-locations (get-locations year-no week-no))
             (games (get-games year-no week-no)) )
        (hash-map->list (lambda (a b) (format #t "~8a => ~a~%" a b) #t) box-locations)
        ; (draw-matches cr box-locations games)
        (draw-matches-newly cr box-locations games)))))

(define-class <box-location> ()
  (afc?       #:init-keyword    #:afc?
              #:getter          box.afc?)
  (div-no     #:init-keyword    #:div-no
              #:getter          box.div-no)
  (team-no    #:init-keyword    #:team-no
              #:getter          box.team-no)
)

(define-method (write (loc <box-location>) out)
  (format out "[~a : Div ~a, Team ~a]" (if (box.afc? loc) 'AFC 'NFC) (box.div-no loc) (box.team-no loc)))

(define-method (mooring-x (loc <box-location>))
  (if (box.afc? loc)
      box-width
      (- (+ box-width graph-width))))

(define-method (mooring-y (loc <box-location>))
  (+ (* (box.div-no loc)
        (+ (* 4 box-height)
           (* 3 team-space)
           div-space))
     (* (box.team-no loc)
        (+ box-height
           team-space))
     (+ (floor (/ box-height 2)))))

(define-method (box-rank (loc <box-location>))
  (+ (* 4 (box.div-no loc)) (box.team-no loc)))

(define (get-locations year-no week-no)
  (let ( (box-positions (make-hash-table)) )
    (define (draw-division afc? div-no teams)
      (define (proc team-no todo)
        (if (not (null? todo))
            (let ( (team-nick (car todo))
                   (box-pos (make-instance <box-location> #:afc? afc? #:div-no div-no #:team-no team-no)) )
              (hash-set! box-positions team-nick box-pos)
              (proc (1+ team-no) (cdr todo)))))
      (proc 0 teams))
    (define (draw-conference afc?)
      (let ( (conf (if afc? 'AFC 'NFC)) )
        (define (proc div-no todo)
          (if (not (null? todo))
              (let ( (next (car todo)) )
                (let ( (teams (map car (get-standings conf next))) )
                  (draw-division afc? div-no teams))
                (proc (1+ div-no) (cdr todo)))))
        (proc 0 '(EAST NORTH SOUTH WEST))))

    (draw-conference #t)
    (draw-conference #f)
    box-positions))
(define (draw-matches-newly cr box-locations games)
  (define (game-conf g)
    (let ( (h (slot-ref g 'home-team))
           (a (slot-ref g 'away-team)) )
      (let ( (h-team (get-team h))
             (a-team (get-team a)) )
        (if (eq? (team.conf h-team) (team.conf a-team)) (team.conf h-team) #f))))
  (define (afc-only g) (eq? 'AFC (game-conf g)))
  (define (nfc-only g) (eq? 'NFC (game-conf g)))
  (define (league-only g) (not (game-conf g)))
  (define (create-match game)
    (let ( (home-loc (hash-ref box-locations (slot-ref game 'home-team)))
           (away-loc (hash-ref box-locations (slot-ref game 'away-team)))
           (home (get-team (slot-ref game 'home-team)))
           (away (get-team (slot-ref game 'away-team))) )
      (make-instance <match> #:game game #:home home #:away away #:home-loc home-loc #:away-loc away-loc)))
  (let ( (afc-games (sort (map create-match (filter afc-only games)) compare-matches))
         (nfc-games (sort (map create-match (filter nfc-only games)) compare-matches))
         (league-games (sort (map create-match (filter league-only games)) compare-matches)) )
    (let ( (div-afc '())
           (conf-afc '())
           (league '())
           (straight '())
           (conf-nfc '())
           (div-nfc '()) )
      (define (pop-afc-lanes todo)
        ; (format #t "pop-afc-lanes called on ~a~%" todo)
        (if (not (null? todo))
            (let ( (next (car todo)) )
              (if (div-match? next)
                  (let ( (lane (find-available-lane div-afc (box-rank (first-loc next)) (box-rank (second-loc next)))) )
                    ; (format #t "nfc div    : adding ~a - ~a~%" (box-rank (first-loc next)) (box-rank (second-loc next)))
                    (if lane
                        (add-match lane next)
                        (let ( (new-lane (make-instance <lane>)) )
                          (add-match new-lane next)
                          (set! div-afc (cons new-lane div-afc)))))
                  (let ( (lane (find-available-lane conf-afc (box-rank (first-loc next)) (box-rank (second-loc next)))) )
                    ; (format #t "nfc conf    : adding ~a - ~a~%" (box-rank (first-loc next)) (box-rank (second-loc next)))
                    (if lane
                        (add-match lane next)
                        (let ( (new-lane (make-instance <lane>)) )
                          (add-match new-lane next)
                          (set! conf-afc (cons new-lane conf-afc))))))
              (pop-afc-lanes (cdr todo)))))
      (define (pop-nfc-lanes todo)
        ; (format #t "pop-nfc-lanes called on ~a~%" todo)
        (if (not (null? todo))
            (let ( (next (car todo)) )
              (if (div-match? next)
                  (let ( (lane (find-available-lane div-nfc (box-rank (first-loc next)) (box-rank (second-loc next)))) )
                    ; (format #t "afc div    : adding ~a - ~a~%" (box-rank (first-loc next)) (box-rank (second-loc next)))
                    (if lane
                        (add-match lane next)
                        (let ( (new-lane (make-instance <lane>)) )
                          (add-match new-lane next)
                          (set! div-nfc (cons new-lane div-nfc)))))
                  (let ( (lane (find-available-lane conf-nfc (box-rank (first-loc next)) (box-rank (second-loc next)))) )
                    ; (format #t "afc conf    : adding ~a - ~a~%" (box-rank (first-loc next)) (box-rank (second-loc next)))
                    (if lane
                        (add-match lane next)
                        (let ( (new-lane (make-instance <lane>)) )
                          (add-match new-lane next)
                          (set! conf-nfc (cons new-lane conf-nfc))))))
              (pop-nfc-lanes (cdr todo)))))
      (define (pop-league-lanes todo)
        ; (format #t "pop-league-lanes called on ~a~%" todo)
        (if (null? todo)
            (begin
              (format #t "before sort, league lanes = ~a~%" league)
              (set! league (sort-league-lanes league))
              (format #t "after sort, league lanes = ~a~%" league))
            (let ( (next (car todo)) )
              ; (format #t "league    : adding ~a - ~a~%" (box-rank (first-loc next)) (box-rank (second-loc next)))
              (if (eq? (box-rank (first-loc next)) (box-rank (second-loc next)))
                  (begin
                    (if (null? straight)
                      (set! straight (list (make-instance <lane>))))
                    (add-match (car straight) next))
                  (let ( (lane (find-available-lane league (box-rank (first-loc next)) (box-rank (second-loc next)))) )
                      (if lane
                          (add-match lane next)
                          (let ( (new-lane (make-instance <lane>)) )
                            (add-match new-lane next)
                            (set! league (cons new-lane league))))))
              (pop-league-lanes (cdr todo)))))
      (define (draw-conf-matches afc? lane-no rad offset spacing lanes)
        (if (not (null? lanes))
          (let ( (next (car lanes)) )
            (let ( (x0 (+ box-width (if afc? 0 graph-width)))
                   (x1 (+ box-width
                          (if afc?
                              (+ offset (* lane-no spacing))
                              (- graph-width (+ offset (* lane-no spacing)))))) )
              (define (draw-conf-match m)
                (let ( (y0 (mooring-y (first-loc m)))
                       (y1 (mooring-y (second-loc m))) )
                  (cairo-move-to cr x0 y0)

                  (cairo-line-to cr (if afc? (- x1 rad) (+ x1 rad)) y0)
                  (cairo-curve-to cr x1 y0 x1 y0 x1 (+ y0 rad))
                  
                  (cairo-move-to cr x1 (+ y0 rad))

                  (cairo-line-to cr x1 (- y1 rad))
                  ; (cairo-move-to cr (if afc? (- x1 rad) (+ x1 rad)) y1)
                  (cairo-curve-to cr x1 y1 x1 y1 (if afc? (- x1 rad) (+ x1 rad)) y1)

                  (cairo-line-to cr x0 y1)
                  (cairo-stroke cr)))
              (map draw-conf-match (lane.matches next)))
          (draw-conf-matches afc? (1+ lane-no) rad offset spacing (cdr lanes)))))
      (define (draw-league-matches rad spacing lanes)
        (let ( (start-x (+ box-width
                           (/ (- graph-width (* spacing (- (length lanes) 1))) 2))) )
          (define (draw-league-lanes offset lanes)
            (if (not (null? lanes))
                (let ( (next (car lanes)))
                  (let ( (xm (+ start-x (* spacing offset))) )
                    (define (draw-match m)
                      (if (match-at-afc? m)
                          (cairo-set-source-rgb cr 0.4 0 0)
                          (cairo-set-source-rgb cr 0 0 0.4))
                      (let ( (l0 (first-loc m))
                             (l1 (second-loc m)) )
                        (let ( (x0 (if (box.afc? l0)
                                       box-width
                                       (+ box-width graph-width)))
                               (x1 (if (box.afc? l1)
                                       box-width
                                       (+ box-width graph-width)))
                               (y0 (mooring-y l0))
                               (y1 (mooring-y l1)) )
                          (let ( (afc0? (box.afc? l0))
                                 (afc1? (box.afc? l1)) )
                            (if (> (loc-span m) 1)
                                (begin
                                  (cairo-move-to cr x0 y0)
                                  (cairo-line-to cr (if afc0? (- xm rad) (+ xm rad)) y0)
                                  (cairo-curve-to cr xm y0 xm y0 xm (+ y0 rad))
                                  (cairo-line-to cr xm (- y1 rad))
                                  (cairo-curve-to cr xm y1 xm y1 (if afc1? (- xm rad) (+ xm rad)) y1)
                                  (cairo-line-to cr x1 y1)
                                  (cairo-stroke cr))
                                (begin
                                  (cairo-move-to cr x0 y0)
                                  (cairo-line-to cr (if afc0? (- xm rad) (+ xm rad)) y0)
                                  (cairo-curve-to cr xm y0 xm y0 xm (floor (/ (+ y0 y1) 2)))
                                  (cairo-curve-to cr xm y1 xm y1 (if afc1? (- xm rad) (+ xm rad)) y1)
                                  (cairo-line-to cr x1 y1)
                                  (cairo-stroke cr))
                                  )))))
                    (map draw-match (lane.matches next)))
                  (draw-league-lanes (1+ offset) (cdr lanes)))))
          (draw-league-lanes 0 lanes)))
      (define (draw-straight-matches todo)
        (if (not (null? todo))
            (let ( (next (car todo)) )
              (let ( (y (mooring-y (first-loc next))) )
                (cairo-move-to cr box-width y)
                (cairo-line-to cr (+ box-width graph-width) y)
                (cairo-stroke cr))
              (draw-straight-matches (cdr todo)))))

      (format #t "draw-matches-newly: about to populate afc lanes~%")
      (pop-afc-lanes afc-games)
      (format #t "draw-matches-newly: about to populate nfc lanes~%")
      (pop-nfc-lanes nfc-games)
      (format #t "draw-matches-newly: about to populate league lanes~%")
      (pop-league-lanes league-games)
      (format #t "draw-matches-newly: finished populating lanes~%")

      (format #t "div-afc   : ~a~%" div-afc)
      (format #t "conf-afc  : ~a~%" conf-afc)
      (format #t "league    : ~a~%" league)
      (format #t "straight  : ~a~%" straight)
      (format #t "conf-nfc  : ~a~%" conf-nfc)
      (format #t "div-nfc   : ~a~%" div-nfc)

      (let ( (div-rad 15)
             (conf-rad 30)
             (league-rad 45) )
        (cairo-set-source-rgb cr 0.4 0 0)
        (cairo-set-line-width cr 3)
        (draw-conf-matches #t 0 div-rad 20 20 div-afc)

        (cairo-set-line-width cr 1.5)
        (draw-conf-matches #t 0 conf-rad 60 20 conf-afc)

        (cairo-set-line-width cr 1)
        (draw-league-matches league-rad 30 league)
        (if (not (null? straight)) (draw-straight-matches (lane.matches (car straight))))

        (cairo-set-source-rgb cr 0 0 0.4)
        (cairo-set-line-width cr 1.5)
        (draw-conf-matches #f 0 conf-rad 60 20 conf-nfc)

        (cairo-set-line-width cr 3)
        (draw-conf-matches #f 0 div-rad 20 20 div-nfc)))))
(define-class <match> ()
  (game       #:init-keyword  #:game
              #:getter        match.game)
  (home-loc   #:init-keyword  #:home-loc
              #:getter        match.home-loc)
  (home-team  #:init-keyword  #:home
              #:getter        match.home)
  (away-loc   #:init-keyword  #:away-loc
              #:getter        match.away-loc)
  (away-team  #:init-keyword  #:away
              #:getter        match.away)
)

(define-method (first-loc (m <match>))
  ; (format #t "first-loc: (box-rank (match.home-loc m)) = ~a, (box-rank (match.away-loc m)) = ~a~%"
  ;         (box-rank (match.home-loc m)) (box-rank (match.away-loc m)))
  (if (< (box-rank (match.home-loc m)) (box-rank (match.away-loc m)))
      (match.home-loc m)
      (match.away-loc m)))

(define-method (first-conf (m <match>))
  (if (< (box-rank (match.home-loc m)) (box-rank (match.away-loc m)))
      (team.conf (match.home m))
      (team.conf (match.away m))))

(define-method (second-loc (m <match>))
  ; (format #t "second-loc: (box-rank (match.home-loc m)) = ~a, (box-rank (match.away-loc m)) = ~a~%"
  ;         (box-rank (match.home-loc m)) (box-rank (match.away-loc m)))
  (if (> (box-rank (match.home-loc m)) (box-rank (match.away-loc m)))
      (match.home-loc m)
      (match.away-loc m)))

(define-method (second-conf (m <match>))
  (if (< (box-rank (match.home-loc m)) (box-rank (match.away-loc m)))
      (team.conf (match.away m))
      (team.conf (match.home m))))

(define-method (match-at-afc? (m <match>))
  (format #t "Does ~a = ~a?~%" (team.conf (match.home m)) 'AFC)
  (eq? (team.conf (match.home m)) 'AFC))

(define-method (loc-span (m <match>))
  (abs (- (box-rank (match.home-loc m)) (box-rank (match.away-loc m)))))

(define-method (div-match? (m <match>))
  (eq? (team.div (match.home m)) (team.div (match.away m))))

(define (compare-matches m1 m2)
  (let ( (r1 (box-rank (first-loc m1)))
         (r2 (box-rank (first-loc m2))) )
    ; (format #t "compare-matches: r1 = ~a, r2 = ~a, span1 = ~a, span2 = ~a~%" r1 r2 (loc-span m1) (loc-span m2))
    (if (eq? r1 r2)
        (if (< (loc-span m1) (loc-span m2)) m1 m2)
        (if (< r1 r2) m1 m2))))

(define (find-available-lane lanes start end)
  ; (format #t "find-available-lane: called on ~a, ~a-~a~%" lanes start end)
  (if (null? lanes)
      (begin
        ; (format #t "find-available-lane: unable to find a lane for ~a-~a~%" start end)
        #f)
      (let ( (next (car lanes)) )
        ; (format #t "find-available-lane: range = ~a-~a, (lane.through next) = ~a~%" start end (lane.through next))
        (if (span-fits-in-lane? start end (lane.matches next))
            (begin
              ; (format #t "find-available-lane: found lane ~a for ~a~%" next start)
              next)
            (find-available-lane (cdr lanes) start end)))))

(define-class <lane> ()
  (matches    #:init-form    '()
              #:getter       lane.matches)
)

(define-method (add-match (l <lane>) (m <match>))
  (let ( (end (box-rank (second-loc m))) )
    (slot-set! l 'matches (append (lane.matches l) (list m)))))

(define (sort-league-lanes lanes)
  (let ( (cross-ranks (make-cross-ranks lanes)) )
    (define (find-pairs rank todo sofar)
      (if (null? todo)
          sofar
          (let ( (next (car todo)) )
            (let ( (afc (car next))
                   (nfc (cadr next)) )
              (if (and (car next) (cadr next))
                  (find-pairs (1+ rank)
                              (cdr todo)
                              (cons rank sofar))
                  (find-pairs (1+ rank) (cdr todo) sofar))))))

    (format #t "cross-ranks: ~a~%" cross-ranks)
    (let ( (pairs (find-pairs 0 (array->list cross-ranks) '())) )
      (if (null? pairs)
          lanes
          ;; TODO: Find some sort
          (begin
            (format #t "Found Conflicts: ~a~%" pairs)
            (let ( (lane-ids (find-lane-ids cross-ranks pairs)))
              (format #t "lane-ids = ~a~%" lane-ids)
              (let ( (perms (permutations (length lane-ids))) )
                (format #t "perms = ~a~%" perms)
                (let ( (perm (find-valid-perm perms lane-ids pairs cross-ranks)) )
                  (if perm
                      (begin
                        (format #t "found valid perm: ~a~%" (hash-map->list cons perm))
                        (reorder-lanes lanes perm))
                      (begin
                        (format #t "no valid perm found~%")
                        ;; Nothing to be done, so return the original order
                        lanes))))))))))

(define (span-fits-in-lane? start end todo)
  (if (null? todo)
      #t
      (let ( (next (car todo)) )
        (if (or (< end (box-rank (first-loc next)))
                (> start (box-rank (second-loc next))))
            (span-fits-in-lane? start end (cdr todo))
            #f))))
(define (make-cross-ranks lanes)
  (let ( (cross-ranks (make-array #f 16 2)) )
    (format #t "cross-ranks = ~a~%" cross-ranks)
    (define (register-matches at matches)
      (format #t "register-matches called on ~a, ~a~%" at matches)
      (if (not (null? matches))
          (let ( (m (car matches)) )
            ; (format #t "make-cross-ranks: about to set first~%")
            (array-set! cross-ranks at (box-rank (first-loc m)) (if (eq? 'AFC (first-conf m)) 0 1))
            ; (format #t "make-cross-ranks: about to set second~%")
            (array-set! cross-ranks at (box-rank (second-loc m)) (if (eq? 'AFC (second-conf m)) 0 1))
            ; (format #t "make-cross-ranks: set both~%")
            (register-matches at (cdr matches)))))
    (define (register-lanes at todo)
      ; (format #t "register-lanes called on ~a, ~a~%" at todo)
      (if (not (null? todo))
          (let ( (l (car todo)) )
            ; (format #t "register-lanes: l = ~a~%" l)
            (register-matches at (lane.matches l))
            (register-lanes (1+ at) (cdr todo)))))
    (register-lanes 0 lanes)
    ; (format #t "cross-ranks is now ~a~%" cross-ranks)
    cross-ranks))

(define (find-lane-ids cross-ranks lane-ids)
  (define (proc todo sofar)
    (if (null? todo)
        sofar
        (let ( (next (car todo)) )
          (let ( (a (array-ref cross-ranks next 0))
                 (n (array-ref cross-ranks next 1)) )
            (let ( (al (if (and a (not (member a sofar))) (list a) '()))
                   (nl (if (and n (not (member n sofar))) (list n) '())) )
              (proc (cdr todo) (append al nl sofar)))))))
    (proc lane-ids '()))

(define (permutations to)
  (if (<= to 1)
      '((0))
      (apply append (map (lambda (l) (list-insert-at-all (1- to) l)) (permutations (1- to))))))

(define (perm-map p l) (map (lambda (a) (list-ref l a)) p))

(define (find-valid-perm perms lanes pairs cross-ranks)
  (define (check-mapping mapping ranks)
    (define (proc todo)
      (format #t "check-mapping.proc: called on ~a~%" todo)
      (if (null? todo)
          mapping
          (let ( (next (car todo)) )
            (let ( (a (array-ref next 0))
                   (n (array-ref next 1)) )
              (format #t "check-mapping.proc: is ~a < ~a (from m(~a) < m(~a), where m = ~a)~%"
                      (hash-ref mapping a) (hash-ref mapping n) a n (hash-map->list cons mapping))
              (if (< (hash-ref mapping a)
                     (hash-ref mapping n))
                  (proc (cdr todo))
                  #f)))))
      (proc ranks))

  (format #t "find-valid-perms called on ~a, ~a~%" lanes pairs)
  (let ( (lane-pairs (map (lambda (a) (cons (array-ref cross-ranks a 0)
                                            (array-ref cross-ranks a 1)))
                          pairs)) )
    (define (is-valid-perm? perm)
      (let ( (mapping (make-hash-table)) )
        (map (lambda (a b) (hash-set! mapping a b))
             lanes
             (perm-map perm lanes))
        (format #t "mapping for ~a is ~a~%" perm (hash-map->list cons mapping))
        (check-mapping mapping (map (lambda (x) (array-slice cross-ranks x)) pairs))))
    (define (proc todo)
      (if (null? todo)
          #f
          (let ( (valid-perm (is-valid-perm? (car todo))) )
            (if valid-perm
                valid-perm
                (proc (cdr todo))))))
    (format #t "lane-pairs = ~a~%" lane-pairs)
    (let ( (valid-perm (proc perms)) )
      (format #f "valid perm? ~a~%" valid-perm)
      valid-perm)))

(define (reorder-lanes lanes mapping)
  (let ( (num-lanes (length lanes)) )
    (define (proc next sofar)
      (if (>= next num-lanes)
          (reverse sofar)
          (let ( (lane-idx (hash-ref mapping next)) )
            (if lane-idx
                (proc (1+ next) (cons (list-ref lanes lane-idx) sofar))
                (proc (1+ next) (cons (list-ref lanes next) sofar))))))
    (proc 0 '())))

(define (list-insert-at item index lst)
  ; (format #t "list-insert-at: called on ~a, ~a, ~a~%" item index lst)
  (call-with-values (lambda () (split-at lst index))
                    (lambda (front back)
                            ; (format #t "list-insert-at._: called on ~a, ~a~%" front back)
                            (append front (list item) back))))

(define (list-insert-at-all val lst)
  ; (format #t "list-insert-at-all: called on ~a, ~a~%" val lst)
  (let ( (len (length lst)) )
    ; (format #t "list-insert-at-all: len = ~a~%" len)
    (define (sub next sofar)
      ; (format #t "list-insert-at-all.sub: called on ~a, ~a~%" next sofar)
      (if (> next len)
          sofar
          (sub (1+ next) (cons (list-insert-at val next lst) sofar))))
    (sub 0 '())))
